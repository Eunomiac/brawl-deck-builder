# Deck & Card Management Strategy Brainstorming

## Class/Component: "`CardPile`"
Represents a *collection of cards*. Anything that can be described as a "collection of cards" will inherit from this class, including:
- the entire cardpool
- players' collections
- commander decks (both user-created and imported)
- lists of cards associated with a commander deck (e.g. "excluded", "maybe cards", "wishlist")
- dynamically-generated sub-sets of larger `CardPile`s, generated by analysis features, filters, etc. (e.g. results of a "popular cards you aren't playing" would be continuously served as a `CardPile`, likely from another `CardPile` (i.e. the deck those results are attached to); and if a player toggles on "creatures only" while searching any `CardPile`, the filtered results (i.e. creatures only) should likewise be served as a `CardPile`)
- dynamically-generated search results

This common base class for all card collections, however deeply nested, should provide a consistent interface for interacting with cards, regardless of the source of the cards: It could include logic that 'detects' its status in hierarchy of `CardPile` instances the user is viewing, and modify how it displays itself accordingly.
For example, a `CardPile.CardDeck` might be told by User to display its contents in a large window for full interaction: That `CardPile.CardDeck` would call its `render` method (using some sort of container component to derive its dimensions) and display itself as a large window on the page. That `CardPile.CardDeck` may have child `CardPile.DynamicPile`s, such as "Lands", "Creatures", etc., and those child `CardPile.DynamicPile`s would likewise call their `render` methods, but with a different layout and interaction model: an element created from that `CardPile.DynamicPile`'s constituent cards, that can be passed to the parent `CardPile.CardDeck` as a completely-formed `Component` to be displayed as a draggable element.
  - ("DynamicPile" because it is generated on-the-fly, as opposed to a `CardPile.CardDeck` which is a static, user-created collection, and will be dynamically generated and then forgotten frequently and quickly -- a player viewing a `CardPile.CardDeck` might click a button to re-group the cards in the deck in a new way, generating new `CardPile.DynamicPile`s to replace the previous ones, with a transition likely handled by GSAP as the cards swoop into their new positions)

### `CardPile` Base Class Features
Any functionality that could be performed on any collection of cards can go into the base `CardPile` class, while more specific requirements can go into subclasses. Base functionality would likely include:
- rendering the `CardPile`'s contents in various formats
- analysis methods (e.g. "`get manaDistribution()`", "`get newestIncludedSet()`")
- ability to incorporate and manage _child_ `CardPile`s (e.g. a `CardPile.CardDeck` may have several child `CardPile.CardDeck`s of its own (from imported deck lists used in analysis), as well as `CardPile.UserList`s for "maybe cards", "wishlist", etc.)
- ability to generate `CardPile.DynamicPile` children on-the-fly (e.g. a `CardPile.CardDeck` could generate a `CardPile.DynamicPile` of all lands in the deck, or all creatures, or all cards of a certain type, etc.)
- logic for adding/removing cards
- validation logic (e.g. "`includesDuplicates`", "`isValidForColorIdentity(colors)`", "`meetsCompanionCriteria(companion)`")



```typescript
namespace CardPile {

	export interface ViewComponentOptions {
		cssClasses?: [],
		...
	}

	/** A function describing how cards should be grouped. When given an array of Card instances
	 * (or CardPile instances), the function must return an object literal with labels as keys and the
	 * grouped `CardPile` instances as values. */
	export type GroupingFunction = (Array<Card|CardPile>) => Record<string, CardPile>;

}

// Regular JavaScript class
class CardPile {
  constructor(cards = []) {
    this.cards = cards;
  }

  getCardsByType(type) {
    return this.cards.filter(card => card.type === type);
  }

  get ViewComponent({ options: ViewComponentOptions }) {
	  return function DeckView() {

		  const [deck, setDeck] = useState(null);

		  useEffect(() => { // I'm assuming this is "when I'm viewed/displayed"?
			setDeck(this); // update state with new viewed deck, and render it
			// reference to parent
			this.render(options);
		  }, [options]);

	  }
  }

  public isGrouped(groupingFunction: GroupingFunction)

  render(options?: ViewComponentOptions) {

		const {isGrouped} = options ?? {};

		// Just have to return the HTML with any tweaks required by `options`
		const htmlParts: string[] = [
			"<div className=\"deck-view"
		];

		if (typeof isGrouped === "function") {
			htmlParts.push(" deck-grouped")
		}
		htmlParts.push("\">");

		htmlParts.push(`
			<h2>Creatures (${this.creatures.length})</h2>
			  <div className="card-grid">
				${this.creatures.map(card => (
				  <CardDisplay key={card.id} card={card} />
				))}
			  </div>
			  ${/* Other card type sections... */}
		`);

		return htmlParts.join("");
  }
}
```